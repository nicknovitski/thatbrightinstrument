---
layout: post
title: Value Enhancement and Many-to-Many Relationships in Google App Engine
date: '2009-02-24T22:20:00.000-05:00'
author: Nick Novitski
tags:
- Project AV
modified_time: '2009-02-24T22:20:21.221-05:00'
blogger_id: tag:blogger.com,1999:blog-31707300.post-342619944615073976
blogger_orig_url: http://brightinstrument.blogspot.com/2009/02/value-enhancement-and-many-to-many.html
---

<a href="http://www.getrichslowly.org/">Get Rich Slowly</a>, a&nbsp;financial advice column I follow, recently linked to <a href="http://www.newsweek.com/id/181290">this Newsweek article</a> about how luck is less a matter of luck than we think. &nbsp;The findings accord &nbsp;fairly well with my limited observation: some people seem to flounder even in the face of what seem to me to be extremely mild "disasters," while others immediately recover and begin taking positive steps towards fixing the problem.<br /><br />I don't mean to harp on the former group; I myself suffer from bouts of uselessness, anxiety, lassitude and depression, so I know how crippling those feelings can be. &nbsp;But I have noticed that, on rare occasion, I've been able to shake off the shock and make progress as if I wasn't suffering, just by actively thinking that I shouldn't let whatever-it-is stop me.<br /><br />Guilt is a powerful motivator for me, and when I think on those times in the past when I've let something get me down and mired in inaction, I feel the guilt keenly. &nbsp;In order to prevent that as much as I can, I try to respond as positively as I can to every disaster I encounter.<br /><br />Which is how we get to unemployment. <br /><br />When I was informed that I had been laid off, I didn't feel surprised. &nbsp;This was just as the economy was in noticeable shock of its own, and our customers had become noticeably more reticent to approve apparently-optional expenditures like web design. &nbsp;We had grown rapidly the previous year, and we were now set to contract rapidly, and as one of the most junior hires, my parting stood to give the company good return for a mild loss. <br /><br />I also didn't feel angry. &nbsp;When the bearer-of-bad-news began to apologize, I interrupted him to say that - as outlined above - I understood the decision, that I didn't feel it reflected poorly on either of us, and that he should feel free to think of me if the situation ever reversed.<br /><br />I did feel a little sad.  I had enjoyed my time with the company.  I had learned a great deal, and helped good people do good work.  But their hands were tied, and we parted amicably, and they provided me with a good reference and excellent experience.<br /><br />And for that reason, I wasn't afraid: I had been valuable enough to hire in the first place, and now, my value had been greatly enhanced by my contact with this company.  Personally, I had better prospects than ever, so I wasn't worried at all.<br /><br />As it happens, I'm very lucky to have the support network that I do, because as the months went by without any offers, the recession bit deeper.  I still think of myself as an intelligent and valuable person (both because I am, and because thinking otherwise is counterproductive), but I've ended up spending much more time unemployed than I initially predicted.<br /><br />But there have been benefits to this as well.  Between sending all those applications for employment and traveling to help my father with his business, I've been able to work a great deal on a web application I've been mulling over for the past year.&nbsp; Obviously, when it's finished, it can serve as the beginnings of a development portfolio, so working on it has allowed me to continue my professional growth even while not being a paid professional!<br /><br />Out of vague concerns, I'm continuing to keep its name and nature secret, but I wanted to write a safely detail-free article about how I've been passing the time productively, as an encouragement both for myself and others. <br /><br />But, to my mixed pleasure, before I could finish and publish it, it became outdated: I was tendered an offer for a position as an Associate Software Engineer. &nbsp; I never even had the chance to show off my application!<br /><br />Great news, I know, but don't think you've gotten out of hearing about my travails just because they've become less useful.<br /><br />My passion for the application was sparked by learning about Google App Engine and the Python at the 2008 Google I/O developer event.&nbsp; Python is a programming language that is so much fun, I'm quite annoyed I didn't learn about it before last year, Google App Engine is a framework for Python, and also a hosting service, and a framework is a collection of code that does a bunch of work for you, so you can get to the cool part of whatever-you're-making faster. &nbsp;The App Engine framework in particular provides some basic extensions to Python that come in handy for making a web-based application: browser request handlers, database schema and transactions, user account validation, mild image editing, and more.<br /><br />It's super-fun and, inasmuch as it connects you with the database system that makes Google search so blazing fast, quite powerful.&nbsp; <br /><br />My initial work sadly petered out after about a month of learning and practice, because I had become convinced that there was no way to model objects with an arbitrary number of many-to-many relationships to each other, which I saw as vital to my application.<br /><br />Let me explain my perceived problem via code examples, with the names of the variables changed to protect the innocent.<br /><br />Say that we want to have a database of books.  Each book might have all kinds of data associated with it - ISBN, publisher name, copyright information - but we'll keep it simple for the time being.<br /><br /><pre>class Book(db.Model):<br />  name = db.StringProperty()<br /></pre><br />The above code declares the existence of a class named "Book," based on a class named "Model" from the package "db," which contains the everything pertaining to App Engine's datastore.  Book has a single property, called "name," which is declared as being of type "StringProperty," another hand-me-down from db.  There are a host of different Property classes in db - for numbers of varying types, web or email addresses, files - and this one in particular will hold a string, which is short for 'string of characters,' which is short for 'a bunch of numbers, letters and/or symbols in a row.'<br /><br />Let's add another property to this class: a publication date, which we might expect to be handled by the suitably-named Date property.  But since each book might be published multiple times, what we really need is a <i>list</i> of publication dates.<br /><br /><pre>class Book(db.Model):<br />    name = db.StringProperty()<br />    pubdates = db.ListProperty(datetime.datetime)<br /></pre><br />The List property expects you to put the name of a data type (like a property, but simpler) in its parentheses, so that it knows to act as a list (of zero or any positive number) of that particular type, in this case, a date.<br /><br />So far, so simple.  But what if we wanted to extend Book so that each book also stored the name of its author?  You could just add another StringProperty, named "author," but what if you decide your app should store more information particular to each author, like a jacket photo or a short biography?  Since some authors write more than one book, it would be quite annoying to store all that info on each book: for example, if you wanted to change any of it, you would have to update it in the record of every book in that author.<br /><br />The solution is what App Engine calls a ReferenceProperty.  First, we'll put Authors in a class all their own, and then we'll set Books to each refer to one Author.<br /><br /><pre>class Author(db.Model):<br />    firstname = db.StringProperty()<br />    lastname = db.StringProperty()<br /><br />class Book(db.Model):<br />    name = db.StringProperty()<br />    author = db.ReferenceProperty(Author)<br /></pre><br />As you can see, Reference properties, like List properties, want you to put the name of a class in parentheses, and forever after they can be set to link to a particular instance of that named class.<br /><br />Okay, here's where the trouble began. The application I wanted to make involved a network structure, a collection of nodes, each of which might be connected to any number of other nodes.<br /><br />Follow me through this painful series of failures of imagination.<br /><br /><pre>class Node(db.Model):<br />    link = db.ReferenceProperty(Node)<br /></pre><br />This code doesn't run.<br /><br /><pre>class Node(db.Model):<br />    refersTo = db.SelfReferenceProperty()<br /></pre><br />That code runs, because I give it the specialized Self-reference property, but it doesn't let me assign more than one link to any given node.  That would still be useful for some purposes, but not mine.<br /><br /><pre>class Node(db.Model):<br />    refersTo = db.ListProperty(Node)<br /></pre><br />This doesn't work, because Nodes are not one of the standard datatypes that List properties can use.  Nor are Self Reference properties of any kind.<br /><br /><pre>class Link(db.Model):<br />   connectsTo = db.ReferenceProperty(Node)<br /><br />class Node(db.Model):<br />    link = db.ReferenceProperty(Link)<br /></pre><br />Maybe, if I separate out the parts of the link into two different classes, I could at least have unidirectional connections between nodes?<br /><br />Wrong!  This code will not run, because the second line refers to a class, Node, that isn't described until later.  Obviously, the same thing happened if I reversed the position of the classes.  Python has no patience when it comes to errors, which I admit is a good thing, even though it had me languishing for months, thinking my dreams were impossible.<br /><br />The secret lies in the nature of Reference Properties.  Each link from one object to another secretly creates a reverse link back!  So, if I wanted to have a bunch of nodes connected to eachother every which way and traversible in every direction, all I need is:<br /><br /><pre>class Link(db.Model):<br />   connectsFrom = db.ReferenceProperty(Node)<br />   connectsTo = db.ReferenceProperty(Node)<br /><br />class Node(db.Model):<br />    def linksTo(self):<br />        return (x.connectsTo for x in self.connectsFrom_set)<br />    def linkedFrom(self):<br />        return (x.connectsFrom for x in self.connectsTo_set<br /></pre><br />The properties of Link named connectsFrom and connectsTo each create a hidden list of reference properties in the node they link to named, respectively, connnectsFrom_set and connectsTo_set.  Those lists contain every link that points to that node in that way, so all we have to do is give Node a pair of methods that collect the nodes at the other end of all the links that connect to them!&nbsp; Hey presto, problem solved!<br /><br />It's a bit of a programming fable: A very simple change in my understanding (embarrasingly simple, actually) has opened up vast new possibilities in the design.&nbsp; Once I realized what I had been missing, I wrote feverishly for several days, and eventually had perhaps three-quarters of a hideous prototype finished.<br /><br />It would be wonderful to be able to show the finished product as a sign of my ability, but it would be even better to actually launch it as the service I first envisioned!&nbsp; I hope that my new job will still allow me the occasional bit of free time to devote to my baby, because I honestly believe that it could be useful and fun to a lot of people.<br /><br />We'll see what this year brings!<br /><br />-Nick